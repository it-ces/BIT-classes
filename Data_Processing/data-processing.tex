\documentclass{beamer}
\usetheme{Madrid}
\usepackage{pgfplots}
\pgfplotsset{compat=1.15}
\usepackage{mathrsfs}
\usetikzlibrary{arrows}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{comment}
\usepackage{listings}
\usepackage{color}
\definecolor{munsell}{rgb}{0.0, 0.5, 0.69}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{minas}{RGB}{0.244, 0.172, 0.36}
\definecolor{PUJ}{RGB}{44, 86, 151}
\definecolor{PUJ2}{RGB}{43, 93, 156}
\definecolor{PUJ3}{RGB}{20, 52, 107}
\definecolor{cyandk}{rgb}{0.0, 0.72, 0.92}
\setbeamerfont{frametitle}{size=\LARGE ,series=\bfseries}
\setbeamercolor{frametitle}{fg=PUJ2, bg=white} %% title of the beamer
\setbeamercolor{titlelike}
{parent=structure,bg=PUJ2}
\setbeamercolor{title}{fg=white, bg=PUJ3} 
%\setbeamercolor{navigation symbols}{fg=white, bg=white}
\setbeamercolor*{palette primary}{use=structure,fg=black,bg=yellow}
\setbeamercolor*{palette secondary}{use=structure,fg=white,bg=PUJ3}
\setbeamercolor*{palette tertiary}{use=structure,fg=white,bg=PUJ3}

\setbeamercolor{block title}{bg=PUJ3,fg=white}


%% code information
\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  classoffset=1,
  morekeywords={True,False}, keywordstyle=\color{munsell}, 
  classoffset=0, 
  keywordstyle=\color{blue},  
  commentstyle=\color{dkgreen},
  stringstyle=\color{PUJ3},
  numberstyle=\tiny\color{gray},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
}

%% You can change default language in the middle of document with \lstset{language=Java}.


%% PUT or Remove the logo in a slide.


%% Information topic

\institute{Javeriana}
\date{2020}

\title[Pontificia Universidad Javeriana] %optional
{Data processing to data analysis}
\subtitle{Using python.}

\author[Iván Andrés Trujillo Abella] 
{Iván Andrés Trujilllo Abella}

\institute[] 
{
  Facultad de Ingenieria\\
  Pontificia Universidad Javeriana
  \and
  
\textbf{ trujilloiv@javeriana.edu.co}
}

\date[MINTA] % (optional)

\newif\ifplacelogo % create a new conditional
\placelogotrue % set it to true
%\logo{\ifplacelogo\color{red}\rule{.5cm}{.5cm}\fi}
\logo{\ifplacelogo \includegraphics[height= 2.0cm]{pujshield.eps}\fi}



\begin{document}
\frame{\titlepage}



\begin{frame}[fragile]{series in pandas}
A arrangement composed of data the same types and index.

\begin{lstlisting}
import pandas as pd
pd.Series().reset_index(drop=True)
pd.Series().reset_index()
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{operations over series}
\begin{lstlisting}
get(index)
loc[index_start: index_end]  # include last 
iloc[position_start: position_end] # do not include last
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{Missing values in Pandas}
\textbf{Pandas} is related with \textbf{Numpy},
\begin{lstlisting}
n = float('nan')
\end{lstlisting}
This value not is compare with itself to check if is a missing value you can uses $math.isnan(n)$.

the $==$ operator does novt produce the expected result.

\end{frame}




\begin{frame}[fragile]{Missing values in rows and columns}
\begin{lstlisting}
import pandas as pd 
import numpy as np
df = pd.DataFrame([['line',float('nan'),float('nan')] , ['circle','red',10],  [float('nan'),'black',1]], columns=['figure','color','value'])
print(df)
df['figure'].isna().sum()
df.loc[0].isna().sum()
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{dropna method}
A dataframe method, 

\begin{lstlisting}
n = float('nan')
\end{lstlisting}



\end{frame}



\begin{frame}[fragile]{replace a value}
\begin{lstlisting}
df.replace('nan',float('nan'), inplace=True)
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{add}
hello 
\end{frame}





\begin{frame}[fragile]{Special topics in python}
lambda expression, map, reduce, filter, zip and lambda are topics very usual and a bit confusing to a novel.

\end{frame}


\begin{frame}[fragile]{lambda expression}
Until now we have been using the keyword:
note that using lambda we not specify a name, lambda expressions are also called \textbf{anonymous functions}.
\begin{lstlisting}
def f(x,y):
	return x**y
\end{lstlisting}
\begin{lstlisting}
f  = lambda x,y : x**y
f(10,2)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{map}
\textbf{map} is used to apply a function to each element in a iterable object.
\end{frame}


\begin{frame}[fragile]{replace}
\begin{lstlisting}
string = 'latex'
string.replace('t','T')
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{split and join}
\begin{lstlisting}
joined ='-'.join(('a','b','c'))
joined.split("-")
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{Regular expression}
Regexs are very useful to handle strings and perfoming operations over them.
\end{frame}


\begin{frame}[fragile]{regular expressions}
\begin{lstlisting}
import re
re.search('d[a-z]f','ainingdaf')
\end{lstlisting}
this will return the same result as 
\begin{lstlisting}
re.search('d[a-z]f','ainingdef')
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Searching words}
\begin{lstlisting}
hello
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{excluding characters}
\begin{lstlisting}
''.join([i for i in s if not i.isdigit()])
\end{lstlisting}

\begin{lstlisting}
''.join(filter(lambda x: not x.isdigit(), mystr))
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{multiple replacement}
\begin{lstlisting}
s = 'one two one two one'

print(s.translate(str.maketrans({'o': 'O', 't': 'T'})))
# One TwO One TwO One

print(s.translate(str.maketrans({'o': 'XXX', 't': None})))
# XXXne wXXX XXXne wXXX XXXne
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{re.sub()}
so far, we have seen that the old string must match completely, however we can uses re.sub() and re.subn()
\begin{lstlisting}
re.sub('regex',' new string' , 'string to change')
\end{lstlisting}
\end{frame}





\begin{frame}[fragile]{group by}
is as a bysort in stata. this section require attention and it is a powerful techniques to work with data.

\end{frame}







\begin{frame}[fragile]{Merge}
we have two datasets dataset a and dataset b, anad keys in key a and key b.
\begin{lstlisting}
merge = pd.merge(dataA, dataB, left_on='key A', right_on='Key B')
\end{lstlisting}


\begin{lstlisting}
merge = pd.merge(dataA, dataB, left_on='key A', right_on='Key B', indicator=True)
\end{lstlisting}

the main difference with join is that join is based in the index.
What it is the value of \textbf{how=} by default?
\end{frame}


\begin{frame}[fragile]{outer}
\begin{columns}
\column{0.5\textwidth}
\begin{table}[]
\begin{tabular}{ccc}
\textbf{id} & \textbf{city} & \textbf{pop} \\ \hline
'1.1'       & A             & 10           \\
'2.1'       & B             & 11           \\
'3.1'       & C             & 12           \\
'4.1'       & D             & 13          
\end{tabular}
\end{table}


\column{0.5\textwidth}

\begin{table}[]
\begin{tabular}{cc}
\textbf{id}  & \textbf{guns} \\ \hline
'2.1'                 & 'legal'           \\
'3.2'                 & 'ilgeal'         \\
'1.1'                 & 'legal'         \\
'4.2'                 & 'legal'      
\end{tabular}
\end{table}
\end{columns}

\begin{lstlisting}
merge = pd.merge(df1,df2, on='id', indicator=True, how='outer')
\end{lstlisting}

\begin{center}
\begin{table}[]
\begin{tabular}{ccccc}
\textbf{id} & \textbf{city} & \textbf{pop} & \textbf{guns} & \textbf{\_merge} \\ \hline
1.1         & A             & 10.2         & legal         & both             \\
2.1         & B             & 11.0         & legal         & both             \\
3.1         & C             & 4.0          & NaN           & left\_only       \\
4.1         & D             & 5.0          & NaN           & left\_only       \\
3.2         & NaN           & NaN          & ilegal        & right\_only      \\
4.2         & NaN           & NaN          & legal         & right\_only     
\end{tabular}
\end{table}
\end{center}

\end{frame}


\begin{frame}[fragile]{Possible problems}
\begin{lstlisting}
df_one = {
'id':
['colombia','colombia','colombia','zimbawe','zimbawe','argentina'], 
'year':
[2000,2001,2002,2000,2001,2003], 
'pop':
[100,120,311,220,110,331]
}
df_two={
'id':
['zimbawe','zimbawe','argentina','colombia','colombia','colombia'], 
'year':
[2001,2000,2014,2001,2002,2003],
'gdp':
[10,11,31,22,14,6]
}


\end{lstlisting}
\end{frame}

\begin{frame}[fragile]

take in mind that \textbf{on} could be a list if there are more of one identifier as in panel data.

\begin{lstlisting}

df_one = pd.DataFrame(df_one)
df_two = pd.DataFrame(df_two)
print(df_one['id'].duplicated())

merge_df = pd.merge(df_one, df_two, on=['id','year'], how='outer', indicator=True)

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{df['var'].unique()}

\begin{lstlisting}

import pandas as pd
df = pd.DataFrame({'cole':['a','a','b','b','c','c','c','d','e','e'], 'point':[1,2,3,4,5,6,7,8,9,10]})
df['cole'].unique()

\end{lstlisting}

return the unique values 'a','b','c','d','e'.

how is used to model data np.where()?
pd.get_dummies(data[var],prefix= var)
\end{frame}



\begin{frame}[fragile]{Creating aggregate variables}
\begin{verbatim}
bysort drug: egen medp = mean(studytime)
\end{verbatim}


\begin{lstlisting}
gb = df.groupby('drug')['studytime']
df['means'] = gb.transform("mean")
df
\end{lstlisting}
\end{frame}









\begin{frame}[fragile]{filtering}
\begin{lstlisting}
import pandas as pd
df = pd.DataFrame({'cole':['a','a','b','b','c','c','c','d','e','e'], 'point':[1,2,3,4,5,6,7,8,9,10]})
print(df)
df[df['cole'].isin(["a", "b", "d"])]
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{Quantil}
\begin{lstlisting}
import numpy as np
def quantileArray(array): ## A Quantile array
  a =list(np.quantile(array,[0.25,0.50,0.75]))
  arrayq = np.where(array<=a[0], 'Q1', np.where(array<=a[1], 'Q2', 'Q3'))
  return list(arrayq)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{To groups}
\begin{lstlisting}
import pandas as pd
programa   = [
'economics','economics','economics','economics',
'economics','law','law','law'
]

notas_lectura = [10,9,8,4,1,10,4,3]

notas_math = [11,23,44,55,66,21,12,11]

df = pd.DataFrame({'Programa':programa, 'notas_lectura':notas_lectura , 'notas_math':notas_math} )

df.groupby('Programa').agg( mean  = ('notas_math', np.sum),quantiles = ('notas_lectura', lambda x: quantileArray(x)))
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{To groups}{equal size}
\begin{lstlisting}
df['mean'] = df.groupby('Programa')['notas_lectura'].transform('mean')
df['Quantiles'] = df.groupby('Programa')['notas_lectura'].transform(lambda x: quantileArray(x))
\end{lstlisting}
\end{frame}

\begin{comment}
to read 
https://pandas.pydata.org/docs/user_guide/groupby.html

https://www.analyticsvidhya.com/blog/2020/03/understanding-transform-function-python/
\end{comment}


\begin{frame}[fragile]{loc and iloc}{subset}
\begin{lstlisting}
data.iloc['rows', 'columns']
\end{lstlisting}
iloc is based in index or position while 
loc is based in labels or conditionals.
if we ommited the second parameter then, will be selected all colummns in the specific row. Otherwise to slecet a column you need put :
\begin{lstlisting}
data.iloc[:,-1]
\end{lstlisting}
this will select the last column with all rows.
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}
df.iloc[:,[0,2,1]] $ first, third and second column
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{loc and conditions}
\begin{lstlisting}
is_male = df.loc[:, 'sex'] == 'Male'
df_male = df.loc[is_male]
df_male.head()
\end{lstlisting}
\end{frame}


\begin{frame}
take in mind that will be return series or dataframe.
\end{frame}


\begin{frame}[fragile]{Preprocessing}
\begin{lstlisting}
df['ageds'] = [(df.loc[x,'age']-np.mean(df['age']))/np.std(df['age']) for x in df.index]
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}
from sklearn.preprocessing import scale
scale(X)
\end{lstlisting}
\end{frame}



\begin{frame}{Reshaping and Pivot Tables}




\end{frame}



\end{document}