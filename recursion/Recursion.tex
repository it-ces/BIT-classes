\documentclass{beamer}
\usetheme{Madrid}
\usepackage{pgfplots}
\pgfplotsset{compat=1.15}
\usepackage{mathrsfs}
\usetikzlibrary{arrows}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{comment}
\usepackage{listings}
\usepackage{color}
\definecolor{munsell}{rgb}{0.0, 0.5, 0.69}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{minas}{RGB}{0.244, 0.172, 0.36}
\definecolor{PUJ}{RGB}{44, 86, 151}
\definecolor{PUJ2}{RGB}{43, 93, 156}
\definecolor{PUJ3}{RGB}{20, 52, 107}
\definecolor{cyandk}{rgb}{0.0, 0.72, 0.92}
\setbeamerfont{frametitle}{size=\LARGE ,series=\bfseries}
\setbeamercolor{frametitle}{fg=PUJ2, bg=white} %% title of the beamer
\setbeamercolor{titlelike}
{parent=structure,bg=PUJ2}
\setbeamercolor{title}{fg=white, bg=PUJ3} 
%\setbeamercolor{navigation symbols}{fg=white, bg=white}
\setbeamercolor*{palette primary}{use=structure,fg=black,bg=yellow}
\setbeamercolor*{palette secondary}{use=structure,fg=white,bg=PUJ3}
\setbeamercolor*{palette tertiary}{use=structure,fg=white,bg=PUJ3}

\setbeamercolor{block title}{bg=PUJ3,fg=white}


%% code information
\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  classoffset=1,
  morekeywords={True,False}, keywordstyle=\color{munsell}, 
  classoffset=0, 
  keywordstyle=\color{blue},  
  commentstyle=\color{dkgreen},
  stringstyle=\color{PUJ3},
  numberstyle=\tiny\color{gray},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
}

%% You can change default language in the middle of document with \lstset{language=Java}.


%% PUT or Remove the logo in a slide.


%% Information topic

\institute{Javeriana}
\date{2020}

\title[Pontificia Universidad Javeriana] %optional
{Algorithms and complexity \textbf{}}
\subtitle{using python.}

\author[Iván Andrés Trujillo Abella] 
{Iván Andrés Trujilllo Abella}

\institute[] 
{
  Facultad de Ingenieria\\
  Pontificia Universidad Javeriana
  \and
  
\textbf{ trujilloiv@javeriana.edu.co}
}

\date[MINTA] % (optional)

\newif\ifplacelogo % create a new conditional
\placelogotrue % set it to true
%\logo{\ifplacelogo\color{red}\rule{.5cm}{.5cm}\fi}
\logo{\ifplacelogo \includegraphics[height= 1.6cm]{pujshield.eps}\fi}



\begin{document}



\frame{\titlepage}

\begin{frame}{Algorithms and complexity}
The time of execution of a program could be important when large input data.
\end{frame}

\begin{frame}[fragile]{Sorting algorithms}
The problem of sort an unsorted \textbf{list} is a recurrent problem to study the complexity and the efficient in the way how we can solve a problem.
\end{frame}

\begin{frame}[fragile]{Bubble sort algorithm}
this strategy consist in compare the adjacent values and replace the adjacent only if is grater than the previous one.


\begin{lstlisting}
lista = [a,b,c,d,e]
\end{lstlisting}
Assume that  $ a < b < c < d <e$ 

then the first iteration we have 
\begin{verbatim}
[b,c,d,e,a]
\end{verbatim}
translate the first  element for all list until get the last position, in the worst case.

the following list must be iterate over n-1. 

\end{frame}

\begin{frame}[fragile]{Bubble sort algorithm}{Python}
\begin{lstlisting}
data = [99,98,97,96,95]
iter = len(data)
while iter >0:  # or for i in range(0,iter-1):
  for i in range(0,iter-1):
    if data[i]> data[i+1]:
      data[i+1], data[i] = data[i], data[i+1]
  iter = iter -1 
print(data)
\end{lstlisting}
Note that there are only needed $n-1$ iterations due to $n-1$ iteration the first element is the lesser value of the $n$ values.
\end{frame}


\begin{frame}[fragile]{Preliminar 1}
Remember that we can concatenate two list 
\begin{lstlisting}
listaOne=[1,2,3]
listaTwo=[4,5,6]
listaThree = listaOne+ListaTwo
print(listaThree)
\end{lstlisting}
will return:
\begin{verbatim}
[1,2,3,4,5,6]
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Divide and conquer}
This is a strategy to resolve different kind of problems, among them the reduction of iterations.
\end{frame}

\begin{frame}[fragile]{Quick Sort}
We can think in the following method:
\begin{verbatim}
lista = [a,b,c,d,e,f]
\end{verbatim}
lista contain random numbers, take the first of the last and called pivot, and try to sorted to the 

\end{frame}

\begin{frame}[fragile]{Insights}{for code implementation}
The logic behind this is two positional index, 
beginning in 0-index, one index to keep position and the other to iterate over the data,  the idea is keep the values  greater than pivot with position index, and replace by first lesser value in the index iterator, after make the first swap then we need increment the positional index for the next more greater value than pivot.
for this reason we can interchange the last positional index with the pivot value, due it is the first value greater than pivot.
\end{frame}


\begin{frame}[fragile]{Recursive instance}
Note that we can broke up the list. 

\end{frame}



\begin{frame}{Call stack}
what is call stack in recursion?
what is recursive leap of faith

\end{frame}


\begin{frame}[fragile]
\begin{lstlisting}
def loop(k):
  if k ==10:
    print('dont exceed')
  else:
    print(f"loop:{k}")
    loop(k+1)
    print(k)
loop(0)
\end{lstlisting}
\end{frame}

\begin{comment}
strands:
stackable chairs:
pop out:
unravel:
endless:
behold:
neatly:
backtracking:
rushing:
overrated:
pegs:
roll over:
freed up:
spindle:
rods:
nifty:
random guessing:
unwinding:
get down:
crisp:
glad:
unwinds:



\end{comment}



\begin{frame}[fragile]{Recursion}
\begin{equation}
a*b = b+b+b+...+b (a-times)
\end{equation}
\begin{lstlisting}
def product(a,b):
  if a==1:
    return b
  else:
    return b + product(a-1,b)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Recursion}
\begin{equation}
\frac{n(n+1)}{2} = \sum_{i=1}^{n}i
\end{equation}
in  a recursion way?
\begin{lstlisting}
def sum(k):
	if k==0:
		return 0
	else:
	return k + sum(k-1)
\end{lstlisting}
\end{frame}




\begin{frame}[fragile]{Fibonnaci serie}
\begin{equation}
f(9) = 1,1,2,3,5,8,13,21,34
\end{equation}
\begin{lstlisting}
def fibonacci(x):
  i = 0
  a,b = 0,1
  while i < x:
    a,b = b,a+b
    i +=1
    print(a)
\end{lstlisting}
In a recursively way:

\begin{lstlisting}
def fibor(k):
  if k<=2:
    return 1
  else:
    return fibor(k-1) + fibor(k-2)
\end{lstlisting}
\end{frame}






\begin{frame}[fragile]{Power function}
\begin{equation}
\begin{align*}
f(n) &= a^{n} = a*a*a*a...*a(n-times) \\
f(n) &= a*a^{n-1}
\end{align*}
\end{equation}

\begin{lstlisting}
def powerr(a,n):
  if n==0:
    return 1
  else:
    return a*powerr(a,n-1)
\end{lstlisting}
\end{frame}









\begin{frame}{Recursion ideas}
Recursion define a base case, and a recursive case for instance in factorial the base case is $factorial(0) = 1$ and for $x>0$ $n * (n-1)! = factorial(n)$ that is recursive case.
\end{frame}


\begin{frame}{stack}
is a data structure, store information in a FILO (first in last outUntitled3) way
A list is a stack  if only uses the methods append and pop.

\end{frame}


\begin{frame}{Kind of recursion}
tail recursion:


\end{frame}


\begin{frame}[fragile]{Hanoi}
Rules:
you can only move a disk at time
and only a smaller disk could be top of a bigger disk.


Suppose do you have three pegs 
and N disk.
'A''B''C'

the process could be
\begin{verbatim}
To carry out the 1 (biggest) disk to last  tower (C), 
you must carry out the N-1 disk's to the next tower(B),
to carry out the N-1 disk to tower(B),
you must carry out the N-2 disk's to tower(C),
to carry out N-3 disk to C,
carry out N-3 disk to B, 
and so on, repeat
to carry out to reach the smallest disk.

\end{verbatim}

\end{frame}



\begin{frame}[fragile]{Hanoi}
We said a stack of $n$ disk as $Sn$.
\begin{verbatim}
To carry out Sn to C,
you must carry out Sn-1 to B,
to carry out Sn-1 to B,
you must carry out Sn-2 to C,
to carry out Sn-2 to C,
you must carry out Sn-3 to B... and so on to reach S1
\end{verbatim}

\end{frame}



\end{frame}

\begin{frame}[fragile]{Find the maximun value in a list}{$*args$}
\begin{lstlisting}
def max(*args):
    aux = args[0]
    for n in args[1:]:
        if n > aux:
            aux = n
    return res
\end{lstlisting}
\end{frame}



\begin{frame}{Local variable, global variable, and recursion}



\end{frame}



\begin{frame}

\end{frame}





\begin{frame}{Divide and conquer}


\end{frame}




\begin{comment}
ideas on Standford algorithm


dazzling: deslumbrante
went down: bajó
bafflement:
glossing over:
bonafide:
indeed:
crackpot:
karatsuba multiplication
upshot:
bears:
hense:
tuned:
driest:
backbone:
barely:
shelf:
blazingly:
theroy of NP completness:
regurgitating:
flock:
regaled:
cater:
watered:
ancient:
jog:
realizes:
warm up:
ties:
spawn:
sloppy:
bogged down:
meaty:
utmost:
spawnning:
rusty:
stamp:


complexity: lines of codes to be executed.


research about recursion tree method:


\end{comment}





\begin{frame}{Insertion sort}

\end{frame}



\begin{frame}{Merge sort}


\end{frame}






\begin{frame}{Time complexity and sorting}{The worst case}

\begin{itemize}
\item Selection sort $O(n^{2})$
\item Insertion sort $O(n^{2})$
\item Merge sort $O(n log (n))$
\item Quick sort $O(n^{2})$
\end{itemize}


\end{frame}



\begin{frame}[fragile]{Turtle introduction in Colab}
Not need be install it,

\begin{lstlisting}
!pip3 install ColabTurtle
from ColabTurtle.Turtle import *
initializeTurtle()
backward(px) # pixel to back
forward(px) # pixel to forward
left(angles) 
right(angles)

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Turtle}{Draw a rectangle}
\begin{lstlisting}
initializeTurtle()
right(90)
forward(100)
left(90)
forward(100)
left(90)
forward(100)
left(90)
forward(100)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Turtle}{Not line}
\begin{lstlisting}
initializeTurtle()
right(90)
penup()
forward(100)
left(90)
forward(100)
pen(down)
left(90)
forward(100)
left(90)
forward(100)
\end{lstlisting}
You can uses another parameters as \textbf{speed([1-13])} to change the speed of drawing.
\end{frame}



\begin{frame}[fragile]{Loops in turtle}

\begin{lstlisting}
for x in range(4):
  right(90)
  forward(100)
\end{lstlisting}


\begin{lstlisting}

\end{lstlisting}
\end{frame}


\begin{frame}
there are another methods in turtle
\begin{itemize}
\item color
\item pensize
\item width
\end{itemize}
\textbf{set\_pos$(x,y)$} image the screen in halves and representing the x-y coordenate system.
\end{frame}



\end{document}